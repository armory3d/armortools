#version 460
#extension GL_EXT_ray_query : require
#extension GL_EXT_shader_explicit_arithmetic_types : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 10, set = 0, rgba16f) uniform image2D render_target;
layout(binding = 0, set = 0) uniform accelerationStructureEXT scene;
layout(binding = 1, set = 0) readonly buffer IndicesBuffer { uint indices[]; };
layout(binding = 2, set = 0) readonly buffer VerticesBuffer {
    uint vertex_data[];
};

layout(binding = 11, set = 0) uniform RayGenConstantBuffer {
    vec4 v0; // frame, strength, radius, offset
    vec4 v1; // envstr, upaxis
    vec4 v2;
    vec4 v3;
    vec4 v4;
} constant_buffer;

layout(binding = 3, set = 0) uniform texture2D mytexture0;
layout(binding = 4, set = 0) uniform texture2D mytexture1;
layout(binding = 5, set = 0) uniform texture2D mytexture2;
layout(binding = 6, set = 0) uniform texture2D mytexture_env;
layout(binding = 7, set = 0) uniform texture2D mytexture_sobol;
layout(binding = 8, set = 0) uniform texture2D mytexture_scramble;
layout(binding = 9, set = 0) uniform texture2D mytexture_rank;
layout(binding = 12, set = 0) uniform sampler sampler_linear;

const int SAMPLES = 64;
const float PI = 3.1415926535;
const float PI2 = 6.283185307;

struct Vertex {
    uint posxy;
    uint poszw;
    uint nor;
    uint tex;
};

struct RayPayload {
    vec4 color;
    vec3 ray_origin;
    vec3 ray_dir;
};

uint thread_seed = 0;

////
float rand(int pixel_i, int pixel_j, int sample_index, int sample_dimension, int frame) {
    pixel_i += int(frame) * 9;
    pixel_j += int(frame) * 11;
    pixel_i = pixel_i & 127;
    pixel_j = pixel_j & 127;
    sample_index = sample_index & 255;
    sample_dimension = sample_dimension & 255;
    int i = sample_dimension + (pixel_i + pixel_j * 128) * 8;
    int ranked_sample_index = sample_index ^ int(texelFetch(sampler2D(mytexture_rank, sampler_linear),
        ivec2(i % 128, i / 128), 0).r * 255.0);
    i = sample_dimension + ranked_sample_index * 256;
    int value = int(texelFetch(sampler2D(mytexture_sobol, sampler_linear),
        ivec2(i % 256, i / 256), 0).r * 255.0);
    i = (sample_dimension % 8) + (pixel_i + pixel_j * 128) * 8;
    value = value ^ int(texelFetch(sampler2D(mytexture_scramble, sampler_linear),
        ivec2(i % 128, i / 128), 0).r * 255.0);
    float v = (0.5 + float(value)) / 256.0;
    return v;
}

vec2 s16_to_f32(uint val) {
    int a = int(val << 16) >> 16;
    int b = int(val & 0xffff0000u) >> 16;
    return vec2(float(a), float(b)) / 32767.0;
}

vec3 cos_weighted_hemisphere_direction(vec3 n, uint sample_idx, uint seed_val, int frame) {
    float f0 = rand(int(gl_GlobalInvocationID.x), int(gl_GlobalInvocationID.y),
                    int(sample_idx), int(seed_val), frame);
    float f1 = rand(int(gl_GlobalInvocationID.x), int(gl_GlobalInvocationID.y),
                    int(sample_idx), int(seed_val + 1u), frame);
    float z = f0 * 2.0 - 1.0;
    float a = f1 * PI2;
    float r = sqrt(1.0 - z * z);
    float x = r * cos(a);
    float y = r * sin(a);
    return normalize(n + vec3(x, y, z));
}

Vertex get_vertex(uint index) {
    uint base = index * 4u;
    Vertex v;
    v.posxy = vertex_data[base + 0u];
    v.poszw = vertex_data[base + 1u];
    v.nor = vertex_data[base + 2u];
    v.tex = vertex_data[base + 3u];
    return v;
}
////

void main() {
    uvec2 pixel_coord = gl_GlobalInvocationID.xy;
    ivec2 dimensions = imageSize(render_target);

    if (pixel_coord.x >= uint(dimensions.x) || pixel_coord.y >= uint(dimensions.y)) {
        return;
    }

    thread_seed = 0;
    vec2 xy = vec2(pixel_coord) + 0.5;
    vec4 tex0 = texelFetch(sampler2D(mytexture0, sampler_linear), ivec2(xy), 0);

    if (tex0.a == 0.0) {
        imageStore(render_target, ivec2(pixel_coord), vec4(0.0, 0.0, 0.0, 0.0));
        return;
    }

    vec3 pos = tex0.rgb;
    vec3 nor = texelFetch(sampler2D(mytexture1, sampler_linear), ivec2(xy), 0).rgb;
    RayPayload payload;
    vec3 ray_origin = pos;
    vec3 ray_dir;
    float ray_tmin = constant_buffer.v0.w * 0.01;
    float ray_tmax = constant_buffer.v0.z * 10.0;
    vec3 accum = vec3(0.0);

    for (int i = 0; i < SAMPLES; ++i) {
        ray_dir = cos_weighted_hemisphere_direction(nor, uint(i), thread_seed,
                                                     int(constant_buffer.v0.x));
        thread_seed += 1u;

        rayQueryEXT query;
        rayQueryInitializeEXT(query, scene,
            gl_RayFlagsOpaqueEXT,
            0xFF,
            ray_origin,
            ray_tmin,
            ray_dir,
            ray_tmax);

        while(rayQueryProceedEXT(query)) {}

        if (rayQueryGetIntersectionTypeEXT(query, true) == gl_RayQueryCommittedIntersectionTriangleEXT) {
            payload.color = vec4(0.0, 0.0, 0.0, 0.0);
        }
        else {
            payload.color = vec4(ray_dir, 0.0);
        }

        accum += payload.color.rgb;
    }

    accum = normalize(accum / float(SAMPLES)) * 0.5 + 0.5;
    if (constant_buffer.v1.y > 0.0) {
        accum.xyz = vec3(accum.x, accum.z, 1.0 - accum.y);
    }

    vec3 color = imageLoad(render_target, ivec2(pixel_coord)).xyz;
    if (constant_buffer.v0.x == 0.0) {
        color = accum;
    }
    else {
        float a = 1.0 / constant_buffer.v0.x;
        float b = 1.0 - a;
        color = color * b + accum * a;
    }

    imageStore(render_target, ivec2(pixel_coord), vec4(color, 1.0));
}
